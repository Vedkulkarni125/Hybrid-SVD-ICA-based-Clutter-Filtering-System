% Final_Block_Processing.m
% BLOCK-WISE GPU SVD PIPELINE (Stable Memory Architecture)
% 1. CPU: Divides image into overlapping blocks
% 2. GPU: Processes ONE block at a time (SVD Denoising)
% 3. CPU: Stitches core regions back (No grid artifacts)
% 4. Result: High-Res Processing with tiny VRAM footprint

clear; clc; close all;

% --- PARAMETERS ---
BLOCK_SIZE = 256;       % Size of processing unit
OVERLAP    = 16;        % Overlap to prevent edge artifacts
CORE_SIZE  = BLOCK_SIZE - 2*OVERLAP; % The valid data region

% 1. SAFETY RESET
try gpuDevice([]); catch, end

% =========================================================================
% STEP 1: INITIALIZATION (CPU / RAM)
% =========================================================================
disp('--- Mode: Block-Wise SVD Processing ---');

% Load DICOM (High Precision)
[f, p] = uigetfile('*.dcm', 'Select DICOM Ultrasound');
if isequal(f,0), return; end
path = fullfile(p, f);

% Load Logic
raw = dicomread(path);
if ndims(raw) == 4
    mid = ceil(size(raw,4)/2);
    raw = squeeze(raw(:,:,1,mid));
elseif ndims(raw) == 3
    mid = ceil(size(raw,3)/2);
    raw = raw(:,:,mid);
end

% Normalize to Double 0.0 - 1.0 (Keep RAM usage low)
original_image = double(raw);
if size(original_image,3)==3, original_image = rgb2gray(original_image); end
original_image = (original_image - min(original_image(:))) / (max(original_image(:)) - min(original_image(:)));

[H, W] = size(original_image);

% Allocate Output Image (CPU RAM)
output_image = zeros(H, W);

% =========================================================================
% STEP 2: BLOCK GRID COMPUTATION
% =========================================================================
num_blocks_x = ceil(W / CORE_SIZE);
num_blocks_y = ceil(H / CORE_SIZE);

fprintf('Processing %d x %d blocks (%d total)...\n', ...
    num_blocks_x, num_blocks_y, num_blocks_x * num_blocks_y);

% =========================================================================
% STEP 3: MAIN PROCESSING LOOP
% =========================================================================
hWait = waitbar(0, 'GPU Processing Blocks...');

total_blocks = num_blocks_x * num_blocks_y;
counter = 0;

for by = 0 : num_blocks_y - 1
    for bx = 0 : num_blocks_x - 1
        
        counter = counter + 1;
        waitbar(counter/total_blocks, hWait);
        
        % --- 4. COMPUTE COORDINATES (CPU) ---
        % Calculate core position in destination
        core_x_start = bx * CORE_SIZE + 1;
        core_y_start = by * CORE_SIZE + 1;
        
        core_x_end = min(core_x_start + CORE_SIZE - 1, W);
        core_y_end = min(core_y_start + CORE_SIZE - 1, H);
        
        % Calculate block position in source (include overlap)
        src_x_start = core_x_start - OVERLAP;
        src_y_start = core_y_start - OVERLAP;
        
        src_x_end = src_x_start + BLOCK_SIZE - 1;
        src_y_end = src_y_start + BLOCK_SIZE - 1;
        
        % --- 5. EXTRACT BLOCK (CPU -> RAM) ---
        % Handle boundary padding manually
        block_in = zeros(BLOCK_SIZE, BLOCK_SIZE);
        
        % Valid intersection with image
        valid_x_start = max(1, src_x_start);
        valid_y_start = max(1, src_y_start);
        valid_x_end   = min(W, src_x_end);
        valid_y_end   = min(H, src_y_end);
        
        % Extract valid region
        img_chunk = original_image(valid_y_start:valid_y_end, valid_x_start:valid_x_end);
        
        % Place into block buffer (centered logic)
        % (Calculate offset where valid data goes into the 256x256 block)
        offset_y = valid_y_start - src_y_start + 1;
        offset_x = valid_x_start - src_x_start + 1;
        
        [chunk_h, chunk_w] = size(img_chunk);
        block_in(offset_y : offset_y+chunk_h-1, offset_x : offset_x+chunk_w-1) = img_chunk;
        
        % --- 6. GPU PROCESSING (ONE BLOCK ONLY) ---
        % a. Move to GPU
        d_A = gpuArray(complex(block_in, 0));
        
        % b. Run SVD Kernel
        try
            [d_U, d_S, d_VT] = mex_hybrid_filter(d_A);
            
            % c. Energy Truncation (95%)
            % Note: d_S is on GPU. We peek at it.
            S_vec = gather(d_S); % Tiny transfer
            energy = cumsum(S_vec.^2) / sum(S_vec.^2);
            k = find(energy >= 0.95, 1);
            if isempty(k), k = length(S_vec); end
            
            % d. Reconstruct on GPU
            % U(:,1:k) * S(1:k) * VT(1:k,:)
            d_S_mat = diag(d_S(1:k));
            d_block_out = d_U(:,1:k) * d_S_mat * d_VT(1:k,:);
            
            % e. Gather back to CPU
            block_out = abs(gather(d_block_out));
            
        catch
            % CPU Fallback if GPU hiccup
            [U,S,V] = svd(block_in, 'econ');
            block_out = U * S * V'; 
        end
        
        % Clear GPU Memory for next iteration
        clear d_A d_U d_S d_VT d_block_out;
        
        % --- 7. REMOVE OVERLAP (CPU) ---
        % Extract only the valid core (middle 224x224)
        % We map the core coordinates relative to the block buffer
        
        valid_block_x_start = (core_x_start - src_x_start) + 1;
        valid_block_y_start = (core_y_start - src_y_start) + 1;
        
        valid_block_x_end = valid_block_x_start + (core_x_end - core_x_start);
        valid_block_y_end = valid_block_y_start + (core_y_end - core_y_start);
        
        core_block = block_out(valid_block_y_start:valid_block_y_end, ...
                               valid_block_x_start:valid_block_x_end);
                           
        % --- 8. STITCH INTO OUTPUT (CPU) ---
        output_image(core_y_start:core_y_end, core_x_start:core_x_end) = core_block;
        
    end
end
close(hWait);

% =========================================================================
% STEP 10: FINAL POST-PROCESSING (Global)
% =========================================================================
disp('Stitching Complete. Applying Global Enhancement...');

% A. Gentle Laplacian (0.06)
lap_kernel = [0 -1 0; -1 4 -1; 0 -1 0];
edges = conv2(output_image, lap_kernel, 'same');
Final_Image = output_image + 0.06 * edges;
Final_Image(Final_Image < 0) = 0;

% B. Relaxed Contrast (1-99%)
low = prctile(Final_Image(:), 1);
high = prctile(Final_Image(:), 99);
Final_Image = (Final_Image - low) / (high - low);
Final_Image = max(min(Final_Image, 1), 0);

% C. Log Compression
Final_Image = log(1 + Final_Image);
Final_Image = mat2gray(Final_Image);

% =========================================================================
% VISUALIZATION
% =========================================================================
figure('Name', 'Block-Wise SVD Result', 'Color', 'white');

subplot(1,2,1); imshow(original_image, []); title('Original');
subplot(1,2,2); imshow(Final_Image, []); 
title(['Processed (Blocks: ' num2str(total_blocks) ')']);

msgbox('Block-Wise Processing Complete.', 'Success');
